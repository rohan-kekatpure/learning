
<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

        <title>Babylon.js sample code</title>

        <!-- Babylon.js -->
        <script src="https://code.jquery.com/pep/0.4.2/pep.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
        <script src="https://preview.babylonjs.com/ammo.js"></script>
        <script src="https://preview.babylonjs.com/cannon.js"></script>
        <script src="https://preview.babylonjs.com/Oimo.js"></script>
        <script src="https://preview.babylonjs.com/libktx.js"></script>
        <script src="https://preview.babylonjs.com/earcut.min.js"></script>
        <script src="https://preview.babylonjs.com/babylon.js"></script>
        <script src="https://preview.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>
        <script src="https://preview.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
        <script src="https://preview.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
        <script src="https://preview.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
        <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.js"></script>
        <script src="https://preview.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
        <script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>

       <style>
        html, body {            
            display: flex;
        }
        #renderCanvas {
            width: 336px;
            height: 448px;
        }
      </style>
    </head>
<body>
    <canvas id="renderCanvas"></canvas>
    <script>
        var canvas = document.getElementById("renderCanvas");

        var engine = null;
        var scene = null;
        var sceneToRender = null;
        var createDefaultEngine = function() { return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true }); };
        
        //sample result from calling the SAA endpoint
        //[-7.1299,-0.5342,-6.9914],"rotation":[-0.0535,0.7946,0.0108]  
        var resp = '{"status" : 1, "camera" : {"position" : [-7.967067992665994 ,1.1182237774893147, -5.9380138685789605], "rotation" : [0.11213684046206573, 0.9302740143714194, 1.4189774925510434e-05], "fov" : 0.7177057601395903}, "planes" : [{"type" : "floor", "position" : [0.0, -3.0, 0.0], "rotation" : [0.0, 0.0, 0.0], "size" : [4000.0, 4000.0], "origin" : [0.0, -3.0, 0.0]}]}';

        var config = JSON.parse(resp);
        
        var createScene = function () {
            var scene = new BABYLON.Scene(engine);
            /* this is where the background image is inserted */
            //Setting up camera with data in config
            var r = 1.0;
            var camera = new BABYLON.UniversalCamera("UniversalCamera", new BABYLON.Vector3(0 ,0, 0), scene);
            camera.name = "OK";
            
            // the GLB model to be inserted into the scene.
            BABYLON.SceneLoader.Append("https://aarwild.s3.amazonaws.com/jobs/01b140c7/packaging/", "mesh.glb", scene, function (scene) {
            /* this is where the background image is inserted */
            var background = new BABYLON.Layer("back", "https://arinthewild.s3.us-east-2.amazonaws.com/img/floors/9/IMG_5930.JPG", scene);
            background.isBackground = true;
            background.texture.level = 0;
            background.texture.wAng = .0;
        
            /*
            var forground = new BABYLON.Layer("front", "https://arinthewild.s3.us-east-2.amazonaws.com/Picture1.png", scene);
            forground.isBackground = false;
            forground.texture.level = 0;
            forground.texture.wAng = .0;
            */
        
            var plane = config.planes[0];
            var origin = config.planes[0].origin;
        
        
            //ground
            //Material for the groun plane
            var groundMaterial = new BABYLON.StandardMaterial("ground", scene);
            groundMaterial.specularColor = BABYLON.Color3.Black();
            //make the ground invisible
            groundMaterial.alpha = 0.3;
            var ground = BABYLON.MeshBuilder.CreateGround("ground", {width:plane.size[0] * 5, height:plane.size[1] * 5}, scene, false);
            ground.position.z = origin[0];
            ground.position.y = origin[1];
            ground.position.x = origin[2];
            ground.rotation = new BABYLON.Vector3(plane.rotation[0], plane.rotation[1], plane.rotation[2]);
            ground.material = groundMaterial;
        
            //scene.createDefaultCameraOrLight(true, true, true);    
            scene.activeCamera.position = new BABYLON.Vector3(config.camera.position[0] * r, config.camera.position[1] * r, config.camera.position[2] * r);
            scene.activeCamera.rotation = new BABYLON.Vector3(config.camera.rotation[0], config.camera.rotation[1], config.camera.rotation[2]);            
            scene.activeCamera.fov = config.camera.fov;
            //var light = new BABYLON.PointLight("pointLight", new BABYLON.Vector3(origin[0], 10 * origin[1], 5 * origin[2]), scene);
            //var light = new BABYLON.HemisphericLight("HemiLight", new BABYLON.Vector3(0, 1, 0), scene);

            var light = new BABYLON.DirectionalLight("DirectionalLight", new BABYLON.Vector3(0, -1, 0), scene);
            light.intensity = 5.;

            var light1 = new BABYLON.DirectionalLight("DirectionalLight", new BABYLON.Vector3(0, 1, 0), scene);
            light1.intensity = 5.;
        
            scene.activeCamera.detachControl(canvas);
        
            var newMeshes = [];
            for (m of scene.meshes)
            {
                // the new model is placed in "origin" reported by config        
                if (m.name != 'ground' && m.name != '__root__')
                {   
                    newMeshes.push(m);
                    m.scaling = m.scaling.multiplyByFloats(3., 3., 3.);
                    m.position.x = origin[0];
                    m.position.y = origin[1];
                    m.position.z = origin[2];
                }
            }
            var totalMesh = BABYLON.Mesh.MergeMeshes(newMeshes,true, true, undefined, false, true);
            /* This point on is UI interaction
            ************************************/
            //interactions
            var startingPoint;
            var currentMesh;
            let ROTATE_Z = new BABYLON.Vector3(0, 1, 0);
        
            var getGroundPosition = function () {
                var pickinfo = scene.pick(scene.pointerX, scene.pointerY, function (mesh) { return mesh == ground; });
                if (pickinfo.hit) {
                    return pickinfo.pickedPoint;
                }
                return null;
            }
        
            var pointerDown = function (mesh) {
                    currentMesh = mesh;
                    startingPoint = getGroundPosition();
                    if (startingPoint) { // we need to disconnect camera from canvas
                        setTimeout(function () {
                            scene.activeCameras.detachControl(canvas);
                        }, 0);
                    }      
            }
        
            var keyDown = function (mesh) {
                    currentMesh = mesh;
                    startingPoint = getGroundPosition();
                    if (startingPoint) { // we need to disconnect camera from canvas
                        setTimeout(function () {
                            scene.activeCameras.detachControl(canvas);
                        }, 0);
                    }
            }
        
        
            var pointerUp = function () {
                if (startingPoint) {
                    //camera.attachControl(canvas, true);
                    startingPoint = null;
                    return;
                }
            }
        
            var pointerMove = function () {
                if (!startingPoint) {
                    return;
                }
                var current = getGroundPosition();
                if (!current) {
                    return;
                }
        
                var diff = current.subtract(startingPoint);
                //diff = diff.multiplyByFloats(.3, .3, .3);
                currentMesh.position.addInPlace(diff);
        
                startingPoint = current;
        
            }
        
            scene.onPointerObservable.add((pointerInfo) => {            
                switch (pointerInfo.type) {            
                    case BABYLON.PointerEventTypes.POINTERDOWN:
                        if(pointerInfo.pickInfo.hit && pointerInfo.pickInfo.pickedMesh != ground) {
                            pointerDown(pointerInfo.pickInfo.pickedMesh)
                        }
                        break;
                    case BABYLON.PointerEventTypes.POINTERUP:
                            pointerUp();
                        break;
                    case BABYLON.PointerEventTypes.POINTERMOVE:          
                            pointerMove();
                        break;                 
                }
            });
        
        

            var unitVec = new BABYLON.Vector3(0, 1, 0);

            var advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI", true, scene);
            
            var slider = new BABYLON.GUI.Slider();
            slider.minimum = 0.0;
            slider.maximum = 2 * 3.141592;
            slider.value = 0;
            slider.height = "20px";
            slider.width = "150px";
            slider.color = "#003399";
            slider.background = "grey";
            slider.left = "120px";
            slider.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
            slider.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;
            slider.onValueChangedObservable.add(function (value) {
                totalMesh.rotation = unitVec.scale(value);
            });


            advancedTexture.addControl(slider);


        
            });
            ///////////////////////////////////////////////////////////////////////////////


            
        
            return scene;
        };
        
        engine = createDefaultEngine();
        if (!engine) throw 'engine should not be null.';
        scene = createScene();;
        sceneToRender = scene

        engine.runRenderLoop(function () {
            if (sceneToRender) {
                sceneToRender.render();
            }
        });

        // Resize
        window.addEventListener("resize", function () {
            engine.resize();
        });
    </script>

</body>
</html>
